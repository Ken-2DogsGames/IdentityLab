<!DOCTYPE html>
<html>
<head>
    <style>
        /* BASE CSS */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Roboto', sans-serif; min-height: 250px; }
        canvas { display: block; width: 100%; height: 100%; } 
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
        }

        /* HUD */
        #hud-left { position: absolute; top: 30px; left: 30px; text-align: left; text-shadow: 0 0 10px #000; }
        .app-title { font-size: 32px; font-weight: 800; color: #fff; letter-spacing: 2px; margin-bottom: 2px; }
        .app-subtitle { font-size: 14px; color: #fff; text-transform: uppercase; font-weight: bold; letter-spacing: 1px; }

        /* DEBUG R DISPLAY */
        #hud-right { position: absolute; top: 30px; right: 30px; text-align: right; text-shadow: 0 0 10px #000; }
        .debug-val { font-family: 'Courier New', monospace; font-size: 14px; color: #0ff; font-weight: bold; }

        #hud-top { margin-top: 120px; text-align: center; text-shadow: 0 0 10px #000; }
        .big-val { font-size: 32px; font-weight: 800; color: #fff; letter-spacing: 2px; }
        .sub-val { font-size: 14px; color: #aaa; text-transform: uppercase; margin-top: 5px; font-weight: bold; }
        .energy-val { margin-top: 4px; }

        /* CONTROLS */
        #controls-wrapper {
            position: absolute; bottom: 30px; width: 100%;
            display: flex; justify-content: center; gap: 20px;
            pointer-events: auto; padding: 0 20px;
        }

        .panel {
            background: rgba(5, 10, 15, 0.95);
            border: 1px solid #333; border-radius: 12px;
            padding: 15px 20px; width: 340px;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        /* V101: Header UI Polish */
        .panel-header-row {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #333; padding-bottom: 5px; margin-bottom: 10px;
        }
        .panel-title {
            font-size: 10px; font-weight: bold; color: #666; text-transform: uppercase; letter-spacing: 1px;
        }
        .ai-mode-wrapper {
            display: flex; align-items: center; gap: 4px; 
        }
        .ai-label {
            font-size: 10px; font-weight: bold; color: #00e5ff; /* Blue */
            text-transform: uppercase; letter-spacing: 1px;
        }
        /* Custom Checkbox Styling */
        input[type=checkbox] {
            appearance: none; width: 14px; height: 14px;
            border: 2px solid #00e5ff; border-radius: 3px;
            background: transparent; cursor: pointer;
            position: relative;
        }
        input[type=checkbox]:checked {
            background: #00e5ff;
        }
        input[type=checkbox]:checked::after {
            content: ''; position: absolute;
            left: 3px; top: 0px; width: 4px; height: 8px;
            border: solid #000; border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }


        .slider-row { display: flex; align-items: center; gap: 15px; margin-bottom: 8px; }
        .slider-row:last-child { margin-bottom: 0; }
        label { width: 120px; color: #00e5ff; font-size: 11px; font-weight: bold; letter-spacing: 1px; }
        input[type=range] { flex: 1; accent-color: #00e5ff; cursor: pointer; }
        .val-display { width: 30px; color: #fff; font-size: 11px; font-weight: bold; text-align: right; }

        #panel-fec { border-color: #443300; }
        #panel-fec .panel-title { color: #aa7700; }
        #panel-fec label { color: #ffaa00; }
        #panel-fec input[type=range] { accent-color: #ffaa00; }

    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="ui-layer">
    <div id="hud-left">
        <div class="app-title">IDENTITY LAB v0.1</div>
        <div class="app-subtitle">IDENTITY WELLS</div>
    </div>

    <div id="hud-right">
        <div id="debug-r" class="debug-val">R: 0.00</div>
    </div>

    <div id="hud-top">
        <div id="coh-display" class="big-val">COHERENCE 100%</div>
        <div id="state-display" class="sub-val" style="color:#0f0">SYSTEM STABLE</div>
        <div id="energy-display" class="sub-val energy-val" style="color:#0f0">ENERGY: OK</div>
    </div>

    <div id="controls-wrapper">
        <div class="panel">
            <div class="panel-header-row">
                <span class="panel-title">Environment Variables</span>
                <div class="ai-mode-wrapper">
                    <span class="ai-label">AI MODE</span>
                    <input type="checkbox" id="cb-ai-mode">
                </div>
            </div>
            
            <div class="slider-row">
                <label>WELL DEPTH</label>
                <input type="range" id="sl-depth" min="0" max="100" value="50">
                <span id="val-depth" class="val-display">50</span>
            </div>
            <div class="slider-row">
                <label>GC SPEND</label>
                <input type="range" id="sl-gc" min="0" max="100" value="50">
                <span id="val-gc" class="val-display">50</span>
            </div>
            <div class="slider-row">
                <label>ENTROPY</label>
                <input type="range" id="sl-noise" min="0" max="100" value="20">
                <span id="val-noise" class="val-display">20</span>
            </div>
            <div class="slider-row">
                <label>ECCENTRICITY</label>
                <input type="range" id="sl-ecc" min="0" max="100" value="0">
                <span id="val-ecc" class="val-display">0</span>
            </div>
        </div>

        <div class="panel" id="panel-fec">
            <div class="panel-header-row">
                <span class="panel-title">Relationship Strength</span>
            </div>
            <div class="slider-row">
                <label>ATTRACTOR 2</label>
                <input type="range" id="sl-str2" min="0" max="100" value="0">
                <span id="val-str2" class="val-display">0</span>
            </div>
            <div class="slider-row">
                <label>ATTRACTOR 3</label>
                <input type="range" id="sl-str3" min="0" max="100" value="0">
                <span id="val-str3" class="val-display">0</span>
            </div>
        </div>
    </div>
</div>

<script>
    window.onerror = function(msg, url, line) { alert("Render Error: " + msg + "\\nLine: " + line); };
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x000000, 0.012);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / Math.max(250, window.innerHeight), 0.1, 200);
    camera.position.set(0, 40, 50); camera.lookAt(0, -5, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, Math.max(250, window.innerHeight));
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2 - 0.1; controls.minDistance = 5; controls.maxDistance = 80;

    window.addEventListener('resize', () => {
        const h = Math.max(250, window.innerHeight);
        camera.aspect = window.innerWidth / h; 
        camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, h);
    });

    // --- STATE ---
    const state = { 
        t: 0, 
        wellDepth: 50, gcSpend: 50, noise: 20, ecc: 0, 
        str2: 0, str3: 0,
        aiMode: false, 
        radius: 7.0, nX: 0, nY: 0, tnX: 0, tnY: 0,
        pX: 7, pZ: 0,
        dEff: 50
    };

    const SPACING = 3.5; 

    // --- TEXTURES (GLOW) ---
    const cvs = document.createElement('canvas'); cvs.width = 128; cvs.height = 128;
    const ctx = cvs.getContext('2d');
    const grad = ctx.createRadialGradient(64,64,0, 64,64,64);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.3, 'rgba(255,255,255,0.4)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad; ctx.fillRect(0,0,128,128);
    const texGlow = new THREE.CanvasTexture(cvs);

    // --- DYNAMIC GEOMETRY ---
    function getAttractorPos(index) {
        const s2 = state.str2 / 100.0;
        const s3 = state.str3 / 100.0;

        if (index === 0) {
            const x = (-SPACING * s2) * (1.0 - (s3 * 0.5)); 
            const z = (-SPACING * 0.8) * s3; 
            return { x: x, z: z };
        }
        if (index === 1) { 
            const x = SPACING * s2; 
            const z = (SPACING * 0.8) * s3; 
            return { x: x, z: z };
        }
        if (index === 2) { 
            const x = -SPACING * s3;
            const z = SPACING * 0.8 * s3;
            return { x: x, z: z };
        }
        return { x: 0, z: 0 };
    }

    // Get Depth of Well at X,Z (v93 Normalization)
    function getWellHeight(x, z) {
        let y = 0;
        const baseDepth = (state.wellDepth / 100.0) * 14.0;
        const s2 = state.str2 / 100.0;
        const s3 = state.str3 / 100.0;
        const totalStrength = s2 + s3; 
        const sigma = 5.0 + (totalStrength * 1.5); 
        const normFactor = 1.0 / (1.0 + (totalStrength * 0.4));
        const weights = [1.0, s2, s3];

        for(let i=0; i<3; i++) {
            if (weights[i] <= 0.01) continue; 
            const pos = getAttractorPos(i);
            let px = pos.x, pz = pos.z;
            if (totalStrength < 0.05) { px = 0; pz = 0; }
            const dx = x - px; const dz = z - pz;
            const distSq = dx*dx + dz*dz;
            y += -baseDepth * weights[i] * normFactor * Math.exp( -distSq / (2 * sigma * sigma) );
        }
        return y;
    }

    // --- ORBIT LOGIC (v90 Unified) ---
    function getOrbitPos(t_angle) {
        
        const s2 = state.str2 / 100.0;
        const s3 = state.str3 / 100.0;
        const totalStrength = s2 + s3; 

        // Update Effective Depth (Physics Ghost Only)
        state.dEff = state.wellDepth + ((totalStrength * 100.0) * 0.05);
        if(state.dEff > 100) state.dEff = 100;

        // Centroid
        let sumX=0, sumZ=0, sumW=0;
        const weights = [1.0, s2, s3];
        for(let i=0; i<3; i++) {
            if(weights[i] > 0.01) {
                let pos = getAttractorPos(i);
                if(totalStrength < 0.05) pos = {x:0, z:0};
                sumX += pos.x * weights[i];
                sumZ += pos.z * weights[i];
                sumW += weights[i];
            }
        }
        const cX = (sumW > 0) ? sumX / sumW : 0;
        const cZ = (sumW > 0) ? sumZ / sumW : 0;

        // RADIUS MAPPING
        const dNorm = state.dEff / 100.0; 
        const rMid = 10.0 - (3.0 * Math.sqrt(dNorm)) - (0.5 * totalStrength);
        const stiffness = 0.6 + (4.0 * dNorm) + (7.5 * totalStrength);
        const flex = (40.0 / stiffness) * (0.5 - (state.gcSpend / 100.0));
        
        let r = rMid + flex;
        if(r < 0.1) r = 0.1; if(r > 30) r = 30;

        // 3. Shape Deformation (v92/v94)
        const scaledEcc = state.ecc * 0.5; 
        let stretchX = 1.0 + (scaledEcc/100.0);
        let squashZ = 1.0 - (scaledEcc/200.0);
        const imbalance = Math.abs(s2 - s3); 
        const relationshipFactor = Math.min(1.0, totalStrength * 5.0); 
        
        const intrinsicStretch = (imbalance * 0.6) * relationshipFactor;
        stretchX += intrinsicStretch;

        let orbX = Math.cos(t_angle) * r * stretchX;
        let orbZ = Math.sin(t_angle) * r * squashZ;

        // Rotation
        const pos1 = getAttractorPos(0);
        const pos2 = getAttractorPos(1);
        const pos3 = getAttractorPos(2);
        
        let rotX = 0, rotZ = 0;
        if (totalStrength > 0.05) {
            const tX = (pos2.x * s2 + pos3.x * s3) / totalStrength;
            const tZ = (pos2.z * s2 + pos3.z * s3) / totalStrength;
            const vX = tX - pos1.x;
            const vZ = tZ - pos1.z;
            const theta = Math.atan2(vZ, vX);
            const c = Math.cos(theta);
            const s = Math.sin(theta);
            rotX = orbX * c - orbZ * s;
            rotZ = orbX * s + orbZ * c;
        } else {
            rotX = orbX;
            rotZ = orbZ;
        }

        return { x: cX + rotX, z: cZ + rotZ, radius: r, cx: cX, cz: cZ, baseR: 5.0 }; 
    }

    // --- OBJECTS ---
    const basinGroup = new THREE.Group(); scene.add(basinGroup);
    const gridSize = 24; const range = 25; const segments = 80; 

    // Surface
    const surfaceGeo = new THREE.PlaneGeometry(range*2, range*2, segments, segments);
    surfaceGeo.rotateX(-Math.PI / 2);
    surfaceGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(surfaceGeo.attributes.position.count * 3), 3));
    const surfaceMesh = new THREE.Mesh(surfaceGeo, new THREE.MeshBasicMaterial({ 
        vertexColors: true, transparent: true, opacity: 0.85, side: THREE.DoubleSide, depthWrite: false 
    }));
    basinGroup.add(surfaceMesh);

    // Grid
    const gridMat = new THREE.LineBasicMaterial({ color: 0x0055aa, transparent: true, opacity: 0.35, depthTest: false });
    const gridLines = [];
    function createLine(isHorizontal, index) {
        const pts = []; const fixed = -range + (2 * range * index / (gridSize - 1));
        for(let i=0; i<=segments; i++) {
            const t = -range + (2 * range * i / segments);
            if(isHorizontal) pts.push(t, 0, fixed); else pts.push(fixed, 0, t); 
        }
        const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
        const line = new THREE.Line(geo, gridMat);
        line.renderOrder = 99; 
        return line;
    }
    for(let i=0; i<gridSize; i++) {
        const l1 = createLine(true, i); basinGroup.add(l1); gridLines.push(l1);
        const l2 = createLine(false, i); basinGroup.add(l2); gridLines.push(l2);
    }

    // Attractors (V97: RENDER ORDER FIX)
    const attractors = [];
    const matPrimary = new THREE.MeshBasicMaterial({ color: 0xff0044, wireframe: true, transparent: true, opacity: 0.4, depthTest: false });
    const matRelation = new THREE.MeshBasicMaterial({ color: 0xffaa00, wireframe: true, transparent: true, opacity: 0.4, depthTest: false });
    const corePrimary = new THREE.MeshBasicMaterial({ color: 0xff0044, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthTest: false });
    const coreRelation = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthTest: false });
    const attGeo = new THREE.IcosahedronGeometry(1.0, 1);
    const coreGeo = new THREE.IcosahedronGeometry(0.5, 0);

    for(let i=0; i<3; i++) {
        const m = (i===0) ? matPrimary : matRelation;
        const c = (i===0) ? corePrimary : coreRelation;
        const mesh = new THREE.Mesh(attGeo, m.clone());
        mesh.add(new THREE.Mesh(coreGeo, c.clone()));
        mesh.renderOrder = 999; 
        const gColor = (i===0) ? 0xff0044 : 0xffaa00;
        const sMat = new THREE.SpriteMaterial({ map: texGlow, color: gColor, blending: THREE.AdditiveBlending, depthTest: false });
        const sprite = new THREE.Sprite(sMat);
        sprite.scale.set(6, 6, 6); 
        sprite.renderOrder = 999; 
        mesh.add(sprite);
        mesh.visible = false; attractors.push(mesh); scene.add(mesh);
    }

    // Particle (V98: X-RAY)
    const particleMat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false, transparent: true });
    const particle = new THREE.Mesh(new THREE.SphereGeometry(0.25, 32, 32), particleMat);
    particle.renderOrder = 999; 
    scene.add(particle);

    // Glow (Particle - Cyan)
    const glowMat = new THREE.SpriteMaterial({ map: texGlow, color: 0x00ffff, blending: THREE.AdditiveBlending, depthTest: false });
    const glowSprite = new THREE.Sprite(glowMat);
    glowSprite.scale.set(4, 4, 4); 
    glowSprite.renderOrder = 999; 
    scene.add(glowSprite);

    // Trail (V99: X-RAY + ALPHA)
    const tailLen = 60; const tailGeo = new THREE.BufferGeometry();
    const tailPos = new Float32Array(tailLen * 3); const tailCol = new Float32Array(tailLen * 4); 
    for(let i=0; i<tailLen; i++) {
        const t = i/(tailLen-1); 
        tailCol[i*4]=1-t; tailCol[i*4+1]=1-(0.5*t); tailCol[i*4+2]=1-(0.5*t);
        tailCol[i*4+3] = 1.0; 
    }
    tailGeo.setAttribute('position', new THREE.BufferAttribute(tailPos, 3));
    tailGeo.setAttribute('color', new THREE.BufferAttribute(tailCol, 4)); 
    
    const tailLine = new THREE.Line(
        tailGeo, 
        new THREE.LineBasicMaterial({ 
            vertexColors: true, transparent: true, opacity: 0.8, 
            blending: THREE.AdditiveBlending, 
            depthTest: false 
        })
    );
    tailLine.renderOrder = 998; 
    scene.add(tailLine);

    // Orbit Guide
    const ringGeo = new THREE.BufferGeometry();
    const ringPts = []; for(let i=0; i<=120; i++) ringPts.push(0,0,0);
    ringGeo.setAttribute('position', new THREE.Float32BufferAttribute(ringPts, 3));
    const ringLine = new THREE.Line(ringGeo, new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4, linewidth: 2 }));
    ringLine.renderOrder = 2; scene.add(ringLine);

    // --- 6. ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);
        state.t += 0.02;

        // V99: AI Mode Logic
        let isVisible = true;
        if (state.aiMode) {
            const cycle = state.t % 3.0;
            isVisible = (cycle < 2.0);
        }
        
        const targetOpacity = isVisible ? 1.0 : 0.0;
        particle.material.opacity = targetOpacity;
        glowSprite.material.opacity = targetOpacity;


        const attWeights = [1.0, state.str2/100.0, state.str3/100.0];
        const totalStrength = attWeights[1] + attWeights[2];
        
        // A. Attractors
        for(let i=0; i<3; i++) {
            let pos = getAttractorPos(i);
            if(totalStrength < 0.05) { pos = {x:0, z:0}; }

            const y = getWellHeight(pos.x, pos.z) + 1.2;
            
            let visible = false;
            let scale = 1.0;
            if (i===0) visible = true;
            else if (attWeights[i] > 0.02) { visible = true; scale = 0.3 + (attWeights[i]*0.7); }

            if(visible) {
                attractors[i].position.set(pos.x, y, pos.z);
                attractors[i].visible = true;
                attractors[i].scale.setScalar(scale);
                attractors[i].rotation.y -= 0.02;
            } else {
                attractors[i].visible = false;
            }
        }

        // B. Surface & Colors
        const pos = surfaceMesh.geometry.attributes.position;
        const col = surfaceMesh.geometry.attributes.color;
        for(let i=0; i<pos.count; i++) {
            const x = pos.getX(i); const z = pos.getZ(i);
            const y = getWellHeight(x, z);
            pos.setY(i, y);
            const dist = Math.sqrt(x*x+z*z);
            const depthNorm = Math.min(1.0, Math.abs(y) / 15.0); 
            const flatFade = Math.max(0, 1.0 - (dist/18.0)); 
            const baseBlue = 0.05 * flatFade;
            col.setXYZ(i, 0.0, 0.05 * depthNorm, baseBlue + (0.25 * depthNorm));
        }
        pos.needsUpdate = true; col.needsUpdate = true;

        gridLines.forEach(l => {
            const arr = l.geometry.attributes.position.array;
            for(let i=0; i<=segments; i++) {
                const idx=i*3; arr[idx+1] = getWellHeight(arr[idx], arr[idx+2]) + 0.05;
            }
            l.geometry.attributes.position.needsUpdate = true;
        });

        // D. PARTICLE
        const orb = getOrbitPos(state.t);
        
        if(Math.floor(state.t * 100) % 3 === 0) {
            const nMag = (state.noise / 100) * 4.5; 
            state.tnX = (Math.random()-0.5)*nMag; state.tnY = (Math.random()-0.5)*nMag;
        }
        state.nX += (state.tnX - state.nX)*0.1; state.nY += (state.tnY - state.nY)*0.1;

        state.pX = orb.x + state.nX;
        state.pZ = orb.z + state.nY;

        const pY = getWellHeight(state.pX, state.pZ);
        particle.position.set(state.pX, pY+0.3, state.pZ);
        glowSprite.position.copy(particle.position);

        // Trail Update (V99: Handles Alpha)
        const tPosArr = tailLine.geometry.attributes.position.array;
        const tColArr = tailLine.geometry.attributes.color.array;
        
        for(let i=tailLen-1; i>0; i--) {
            tPosArr[i*3] = tPosArr[(i-1)*3];
            tPosArr[i*3+1] = tPosArr[(i-1)*3+1];
            tPosArr[i*3+2] = tPosArr[(i-1)*3+2];
            tColArr[i*4+3] = tColArr[(i-1)*4+3];
        }
        
        tPosArr[0]=state.pX; tPosArr[1]=pY+0.3; tPosArr[2]=state.pZ;
        tColArr[3] = isVisible ? 1.0 : 0.0; 

        tailLine.geometry.attributes.position.needsUpdate = true;
        tailLine.geometry.attributes.color.needsUpdate = true;


        // E. GUIDE
        const rArr = ringLine.geometry.attributes.position.array;
        for(let i=0; i<=120; i++) {
            const theta = (i/120)*Math.PI*2;
            const pt = getOrbitPos(theta); 
            const ry = getWellHeight(pt.x, pt.z) + 0.05;
            rArr[i*3] = pt.x; rArr[i*3+1] = ry; rArr[i*3+2] = pt.z;
        }
        ringLine.geometry.attributes.position.needsUpdate = true;

        // HUD - DYNAMIC ZONES (Check Instantaneous Dist)
        // V102: Logic for AI Mode (Suspended Signal)
        if (state.aiMode && !isVisible) {
            // SUSPENDED STATE
            document.getElementById('coh-display').innerText = "COHERENCE ...";
            document.getElementById('debug-r').innerText = "R: ---";
            const sEl = document.getElementById('state-display');
            sEl.innerText = "SIGNAL SUSPENDED";
            sEl.style.color = "#444"; // Dark Grey
        } 
        else {
            // NORMAL UPDATE
            const dx = state.pX - orb.cx;
            const dz = state.pZ - orb.cz;
            const dist = Math.sqrt(dx*dx + dz*dz); 
            
            document.getElementById('debug-r').innerText = "R: " + orb.radius.toFixed(2);

            const deviation = Math.abs(dist - 5.0); 
            const bonus = (totalStrength * 10.0); 
            
            let coh = 100 - (deviation * 12.0) + bonus;
            coh = Math.min(100, Math.max(0, coh));
            
            document.getElementById('coh-display').innerText = "COHERENCE " + coh.toFixed(0) + "%";
            const sEl = document.getElementById('state-display');

            if (dist < 3.0) { 
                sEl.innerText = "SYSTEM RIGIDITY"; sEl.style.color = "#f00"; 
            } 
            else if (dist > 12.0) { 
                sEl.innerText = "DRIFT COLLAPSE"; sEl.style.color = "#f00"; 
            } 
            else if (dist > 9.0) { 
                sEl.innerText = "COHERENCE DRIFT"; sEl.style.color = "#fb0"; 
            } 
            else if (dist > 5.5) { 
                sEl.innerText = "SYSTEM STABLE"; sEl.style.color = "#0f0"; 
            } 
            else {
                sEl.innerText = "DEEP FOCUS"; sEl.style.color = "#0ff";
            }
        }

        const eEl = document.getElementById('energy-display');
        const gc = state.gcSpend;
        if (gc > 80) { eEl.innerText = "ENERGY: EXCESSIVE"; eEl.style.color = "#f00"; }
        else if (gc > 60) { eEl.innerText = "ENERGY: HIGH"; eEl.style.color = "#0ff"; }
        else if (gc > 40) { eEl.innerText = "ENERGY: OK"; eEl.style.color = "#0f0"; }
        else if (gc > 20) { eEl.innerText = "ENERGY: LOW"; eEl.style.color = "#fb0"; }
        else { eEl.innerText = "ENERGY: DEPLETED"; eEl.style.color = "#f00"; }

        controls.update(); renderer.render(scene, camera);
    }
    animate();

    function updateState() {
        state.wellDepth = parseInt(document.getElementById('sl-depth').value);
        document.getElementById('val-depth').innerText = state.wellDepth;

        state.gcSpend = parseInt(document.getElementById('sl-gc').value);
        document.getElementById('val-gc').innerText = state.gcSpend;

        state.noise = parseInt(document.getElementById('sl-noise').value);
        document.getElementById('val-noise').innerText = state.noise;

        state.ecc = parseInt(document.getElementById('sl-ecc').value);
        document.getElementById('val-ecc').innerText = state.ecc;

        state.str2 = parseInt(document.getElementById('sl-str2').value);
        document.getElementById('val-str2').innerText = state.str2;

        state.str3 = parseInt(document.getElementById('sl-str3').value);
        document.getElementById('val-str3').innerText = state.str3;

        state.aiMode = document.getElementById('cb-ai-mode').checked;
    }

    document.querySelectorAll('input').forEach(el => el.addEventListener('input', updateState));
    document.getElementById('cb-ai-mode').addEventListener('change', updateState);
    updateState();

</script>
</body>
</html>
